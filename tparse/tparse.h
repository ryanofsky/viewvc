/*
# Copyright (C) 2000-2002 The ViewCVS Group. All Rights Reserved.
# This file has been rewritten in C++ from the rcsparse.py file by
# Lucas Bruand <lucas.bruand@ecl2002.ec-lyon.fr>
#
# By using this file, you agree to the terms and conditions set forth in
# the LICENSE.html file which can be found at the top level of the ViewCVS
# distribution or at http://viewcvs.sourceforge.net/license-1.html.
#
# Contact information:
#   Greg Stein, PO Box 760, Palo Alto, CA, 94302
#   gstein@lyra.org, http://viewcvs.sourceforge.net/
#
# -----------------------------------------------------------------------
#
# This software is being maintained as part of the ViewCVS project.
# Information is available at:
#    http://viewcvs.sourceforge.net/
#
# This file was originally based on portions of the blame.py script by
# Curt Hagenlocher.
#
# -----------------------------------------------------------------------
#
*/

/*
   This C++ library offers an API to a performance-oriented RCSFILE parser.
   It does little syntax checking.
 
   Version: $Id$
 */
#define CHUNK_SIZE 30000
#ifndef __PARSE_H
#define __PARSE_H
#include <iostream.h>
#include <stdio.h>
#include <fstream.h>
#include <string.h>
#include <stdlib.h>

#define DEFAULT_TOKEN_SIZE 512
#define DEFAULT_TOKEN_DELTA 10240

using namespace std;

/* This class represents a exception that occured during the parsing
   of a file */
class RCSParseError
{
  public:
    const char *value;
    RCSParseError() {};
    RCSParseError(const char *myvalue)
    {
      value = myvalue;
    };
};

class RCSIllegalCharacter : public RCSParseError
{
  public:
    RCSIllegalCharacter(const char *myvalue)
    {
      value = myvalue;
    };
};

class RCSExpected : public RCSParseError
{
  public:
    const char *got;
    const char *wanted;
    RCSExpected(const char *mygot, const char *mywanted)
    {
      got = mygot;
      wanted = mywanted;
    }
};


class rcstoken
{
 public:
  size_t length, size, delta;
  char *data;

 public:
  rcstoken(const char *mydata, size_t mylen)
  {
    init(mydata, mylen);
  };
  rcstoken(const char *mydata)
    {
      init(mydata, strlen(mydata));
    };
  rcstoken(size_t mysize = DEFAULT_TOKEN_SIZE,
           size_t mydelta = DEFAULT_TOKEN_DELTA)
    {
      data = NULL;
      size = mysize;
      length = 0;
      delta = mydelta;
    };
  ~rcstoken()
    {
      if (data)
        free(data);
      data = NULL;
    };
  void rcstoken::init(const char *mydata, size_t mylen);
  int null_token()
    {
      return data == NULL;
    };
  rcstoken& operator=(const char b)
    {
      grow(2);
      length = 1;
      data[0] = b;
      data[1] = 0;

      return *this;
    };
  rcstoken& operator+=(const char b)
    {
      append(b);
    };
  rcstoken& operator+=(rcstoken& token)
    {
      append(token);
    };
  int operator==(const char *b)
    {
      size_t b_len;
      return data && b && length == (b_len = strlen(b)) &&
        memcmp(data, b, (b_len<length) ? b_len : length) == 0;
    };
  int operator!=(const char *b)
    {
      return (! (*this == b));
    };
  int operator==(const char b)
    {
      return (length == 1) && data && (*data == b);
    };
  int operator!=(const char b)
    {
      return (! (*this==b));
    };
  char operator[](size_t i)
    {
      return data[i];
    };
  void append(const char *b, size_t b_len);
  void append(const char b)
    {
      grow(length+2);
      data[length] = b;
      data[length++] = 0;
    };
  void append(rcstoken& token)
    {
      append(token.data, token.length);
    };
  void grow(size_t new_size);
  rcstoken *copy_begin_end(size_t begin, size_t end);
  rcstoken *copy_begin_len(size_t begin, size_t len);
};

/* This class is used to store a list of the branches of a revision */
class Branche
{
  public:
    rcstoken *name;
    Branche *next;
    Branche(rcstoken *myname, Branche *mynext)
    {
      name = myname;
      next = mynext;
    };
    ~Branche()
    {
      delete name;
      name = NULL;
      if (next != NULL)
        delete next;
      next = NULL;
    };
};

/* This class is a handler that receive the event generated by the parser
   i.e.: When we reach the head revision tag, etc... */
class Sink
{
  public:
    Sink() {};
    virtual int set_head_revision(rcstoken *revision) = 0;
    virtual int set_principal_branch(rcstoken *branch_name) = 0;
    virtual int define_tag(rcstoken *name, rcstoken *revision) = 0;
    virtual int set_comment(rcstoken *comment) = 0;
    virtual int set_description(rcstoken *description) = 0;
    virtual int define_revision(rcstoken *revision, long timestamp, 
                                rcstoken *author, rcstoken *state, 
                                Branche *branches, rcstoken *next) = 0;
    virtual int set_revision_info(rcstoken *revision,
                                  rcstoken *log,
                                  rcstoken *text) = 0;
    virtual int tree_completed() = 0;
    virtual int parse_completed() = 0;
};

/* The class is used to get one by one every token in the file. */
class TokenParser
{
  private:
    istream *input;
    char buf[CHUNK_SIZE];
    int buflength;
    int idx;
    rcstoken *backget;
  public:
    char *semicol;
    rcstoken *get();
    void unget(rcstoken *token);
    int eof()
    {
      return (input->gcount() == 0);
    };
    void matchsemicol()
    {
      rcstoken *ptr = get();
      if ((*ptr) != ';')
        throw RCSExpected(ptr->data, semicol);
      delete ptr;
    };
    void match(const char *token)
    {
      rcstoken *ptr = get();
      if (*ptr != token)
        throw RCSExpected(ptr->data, token);
      delete ptr;
    };
    TokenParser(istream *myinput)
    {
      input = myinput;
      backget = NULL;
      idx = 0;
      semicol = ";";
      input->read(buf, CHUNK_SIZE);
      if ( (buflength = input->gcount()) == 0 )
        throw RCSParseError("Non-existing file or empty file");
    };
    ~TokenParser()
    {
      if (input != NULL)
      {
        delete input;
        input = NULL;
      };
      if (backget != NULL)
      {
        delete backget;
        backget = NULL;
      };
    };
};

/* this is the class that does the actual job: by reading each part of
   the file and thus generate events to a sink event-handler*/
class tparseParser
{
  private:
    TokenParser *tokenstream;
    Sink *sink;
    int parse_rcs_admin();
    int parse_rcs_tree();
    int parse_rcs_description();
    int parse_rcs_deltatext();
  public:
    tparseParser(istream *myinput, Sink* mysink)
    {
      sink = mysink;
      tokenstream = new TokenParser(myinput);
    }
    void parse()
    {
      if (parse_rcs_admin())
        return;
      if (parse_rcs_tree())
        return;

      // many sinks want to know when the tree has been completed so they can
      // do some work to prepare for the arrival of the deltatext
      if (sink->tree_completed())
        return;

      if (parse_rcs_description())
        return;
      if (parse_rcs_deltatext())
        return;

      // easiest for us to tell the sink it is done, rather than worry about
      // higher level software doing it.
      if (sink->parse_completed())
        return;
    }
    ~tparseParser()
    {
      delete tokenstream;
      delete sink;
    }
};

#endif /* __PARSE_H */
